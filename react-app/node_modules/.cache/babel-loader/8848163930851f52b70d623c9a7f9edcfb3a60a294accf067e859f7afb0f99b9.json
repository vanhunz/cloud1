{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};","map":{"version":3,"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","sortBy","get","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","findEntryInArray","isNan","isNullish","isNumber","isNumOrStr","mathSign","getSliced","getValueByDataKey","obj","dataKey","defaultValue","appendOffsetOfLegend","offset","legendSettings","legendSize","width","boxWidth","height","boxHeight","align","verticalAlign","layout","isCategoricalAxis","axisType","getCoordinatesOfGrid","ticks","minValue","maxValue","syncWithTicks","map","entry","coordinate","hasMin","hasMax","values","getTicksOfAxis","axis","isGrid","isAll","duplicateDomain","type","range","scale","realScaleType","isCategorical","categoricalDomain","tickCount","niceTicks","offsetForBand","bandwidth","result","index","scaleContent","indexOf","row","domain","EPS","checkDomainOfScale","len","Math","min","max","first","last","truncateByDomain","offsetSign","series","n","j","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","data","dataKeys","offsetType","offsetAccessor","d","key","order","getNormalizedStackId","publicStackId","undefined","getCateCoordinateOfLine","_ref","bandSize","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref2","getBaseValueOfBar","_ref3","numericAxis","getDomainOfSingle","flat","makeDomainFinite","Infinity","getDomainOfStackGroups","stackGroups","startIndex","endIndex","reduce","stackId","group","stackedData","res","sliced","s","MIN_VALUE_REG","MAX_VALUE_REG","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","cur","prev","getTooltipEntry","_ref4","tooltipEntrySettings","payload","name","getTooltipNameProp","nameFromItem","calculateCartesianTooltipPos","chartX","chartY","calculatePolarTooltipPos","rangeObj","angle","radius"],"sources":["C:/Users/LENOVO/Desktop/web/cloud/react-app/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { getSliced } from './getSliced';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack().keys(dataKeys).value((d, key) => Number(getValueByDataKey(d, key, 0))).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var sliced = getSliced(entry, startIndex, endIndex);\n      var s = getDomainOfSingle(sliced);\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport var calculateCartesianTooltipPos = (coordinate, layout) => {\n  if (layout === 'horizontal') {\n    return coordinate.chartX;\n  }\n  if (layout === 'vertical') {\n    return coordinate.chartY;\n  }\n  return undefined;\n};\nexport var calculatePolarTooltipPos = (rangeObj, layout) => {\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};"],"mappings":"AAAA,SAASA,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAAE,IAAIC,CAAC,GAAGC,MAAM,CAACC,IAAI,CAACJ,CAAC,CAAC;EAAE,IAAIG,MAAM,CAACE,qBAAqB,EAAE;IAAE,IAAIC,CAAC,GAAGH,MAAM,CAACE,qBAAqB,CAACL,CAAC,CAAC;IAAEC,CAAC,KAAKK,CAAC,GAAGA,CAAC,CAACC,MAAM,CAAC,UAAUN,CAAC,EAAE;MAAE,OAAOE,MAAM,CAACK,wBAAwB,CAACR,CAAC,EAAEC,CAAC,CAAC,CAACQ,UAAU;IAAE,CAAC,CAAC,CAAC,EAAEP,CAAC,CAACQ,IAAI,CAACC,KAAK,CAACT,CAAC,EAAEI,CAAC,CAAC;EAAE;EAAE,OAAOJ,CAAC;AAAE;AAC9P,SAASU,aAAaA,CAACZ,CAAC,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGY,SAAS,CAACC,MAAM,EAAEb,CAAC,EAAE,EAAE;IAAE,IAAIC,CAAC,GAAG,IAAI,IAAIW,SAAS,CAACZ,CAAC,CAAC,GAAGY,SAAS,CAACZ,CAAC,CAAC,GAAG,CAAC,CAAC;IAAEA,CAAC,GAAG,CAAC,GAAGF,OAAO,CAACI,MAAM,CAACD,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACa,OAAO,CAAC,UAAUd,CAAC,EAAE;MAAEe,eAAe,CAAChB,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAACD,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC,GAAGE,MAAM,CAACc,yBAAyB,GAAGd,MAAM,CAACe,gBAAgB,CAAClB,CAAC,EAAEG,MAAM,CAACc,yBAAyB,CAACf,CAAC,CAAC,CAAC,GAAGH,OAAO,CAACI,MAAM,CAACD,CAAC,CAAC,CAAC,CAACa,OAAO,CAAC,UAAUd,CAAC,EAAE;MAAEE,MAAM,CAACgB,cAAc,CAACnB,CAAC,EAAEC,CAAC,EAAEE,MAAM,CAACK,wBAAwB,CAACN,CAAC,EAAED,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;EAAE;EAAE,OAAOD,CAAC;AAAE;AACtb,SAASgB,eAAeA,CAAChB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAAE,OAAO,CAACD,CAAC,GAAGmB,cAAc,CAACnB,CAAC,CAAC,KAAKD,CAAC,GAAGG,MAAM,CAACgB,cAAc,CAACnB,CAAC,EAAEC,CAAC,EAAE;IAAEoB,KAAK,EAAEnB,CAAC;IAAEO,UAAU,EAAE,CAAC,CAAC;IAAEa,YAAY,EAAE,CAAC,CAAC;IAAEC,QAAQ,EAAE,CAAC;EAAE,CAAC,CAAC,GAAGvB,CAAC,CAACC,CAAC,CAAC,GAAGC,CAAC,EAAEF,CAAC;AAAE;AACnL,SAASoB,cAAcA,CAAClB,CAAC,EAAE;EAAE,IAAIsB,CAAC,GAAGC,YAAY,CAACvB,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI,OAAOsB,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC1G,SAASC,YAAYA,CAACvB,CAAC,EAAED,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI,OAAOC,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIF,CAAC,GAAGE,CAAC,CAACwB,MAAM,CAACC,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAK3B,CAAC,EAAE;IAAE,IAAIwB,CAAC,GAAGxB,CAAC,CAAC4B,IAAI,CAAC1B,CAAC,EAAED,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI,OAAOuB,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIK,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAK5B,CAAC,GAAG6B,MAAM,GAAGC,MAAM,EAAE7B,CAAC,CAAC;AAAE;AACvT,OAAO8B,MAAM,MAAM,0BAA0B;AAC7C,OAAOC,GAAG,MAAM,uBAAuB;AACvC,SAASC,KAAK,IAAIC,UAAU,EAAEC,iBAAiB,EAAEC,eAAe,EAAEC,qBAAqB,EAAEC,iBAAiB,EAAEC,cAAc,QAAQ,yBAAyB;AAC3J,SAASC,gBAAgB,EAAEC,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,QAAQ,QAAQ,aAAa;AAChG,SAASC,SAAS,QAAQ,aAAa;AACvC,OAAO,SAASC,iBAAiBA,CAACC,GAAG,EAAEC,OAAO,EAAEC,YAAY,EAAE;EAC5D,IAAIR,SAAS,CAACM,GAAG,CAAC,IAAIN,SAAS,CAACO,OAAO,CAAC,EAAE;IACxC,OAAOC,YAAY;EACrB;EACA,IAAIN,UAAU,CAACK,OAAO,CAAC,EAAE;IACvB,OAAOjB,GAAG,CAACgB,GAAG,EAAEC,OAAO,EAAEC,YAAY,CAAC;EACxC;EACA,IAAI,OAAOD,OAAO,KAAK,UAAU,EAAE;IACjC,OAAOA,OAAO,CAACD,GAAG,CAAC;EACrB;EACA,OAAOE,YAAY;AACrB;AACA,OAAO,IAAIC,oBAAoB,GAAGA,CAACC,MAAM,EAAEC,cAAc,EAAEC,UAAU,KAAK;EACxE,IAAID,cAAc,IAAIC,UAAU,EAAE;IAChC,IAAI;MACFC,KAAK,EAAEC,QAAQ;MACfC,MAAM,EAAEC;IACV,CAAC,GAAGJ,UAAU;IACd,IAAI;MACFK,KAAK;MACLC,aAAa;MACbC;IACF,CAAC,GAAGR,cAAc;IAClB,IAAI,CAACQ,MAAM,KAAK,UAAU,IAAIA,MAAM,KAAK,YAAY,IAAID,aAAa,KAAK,QAAQ,KAAKD,KAAK,KAAK,QAAQ,IAAIhB,QAAQ,CAACS,MAAM,CAACO,KAAK,CAAC,CAAC,EAAE;MACrI,OAAOhD,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEyC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE;QAClD,CAACO,KAAK,GAAGP,MAAM,CAACO,KAAK,CAAC,IAAIH,QAAQ,IAAI,CAAC;MACzC,CAAC,CAAC;IACJ;IACA,IAAI,CAACK,MAAM,KAAK,YAAY,IAAIA,MAAM,KAAK,UAAU,IAAIF,KAAK,KAAK,QAAQ,KAAKC,aAAa,KAAK,QAAQ,IAAIjB,QAAQ,CAACS,MAAM,CAACQ,aAAa,CAAC,CAAC,EAAE;MAC7I,OAAOjD,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEyC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE;QAClD,CAACQ,aAAa,GAAGR,MAAM,CAACQ,aAAa,CAAC,IAAIF,SAAS,IAAI,CAAC;MAC1D,CAAC,CAAC;IACJ;EACF;EACA,OAAON,MAAM;AACf,CAAC;AACD,OAAO,IAAIU,iBAAiB,GAAGA,CAACD,MAAM,EAAEE,QAAQ,KAAKF,MAAM,KAAK,YAAY,IAAIE,QAAQ,KAAK,OAAO,IAAIF,MAAM,KAAK,UAAU,IAAIE,QAAQ,KAAK,OAAO,IAAIF,MAAM,KAAK,SAAS,IAAIE,QAAQ,KAAK,WAAW,IAAIF,MAAM,KAAK,QAAQ,IAAIE,QAAQ,KAAK,YAAY;;AAE7P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,oBAAoB,GAAGA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,aAAa,KAAK;EAC9E,IAAIA,aAAa,EAAE;IACjB,OAAOH,KAAK,CAACI,GAAG,CAACC,KAAK,IAAIA,KAAK,CAACC,UAAU,CAAC;EAC7C;EACA,IAAIC,MAAM,EAAEC,MAAM;EAClB,IAAIC,MAAM,GAAGT,KAAK,CAACI,GAAG,CAACC,KAAK,IAAI;IAC9B,IAAIA,KAAK,CAACC,UAAU,KAAKL,QAAQ,EAAE;MACjCM,MAAM,GAAG,IAAI;IACf;IACA,IAAIF,KAAK,CAACC,UAAU,KAAKJ,QAAQ,EAAE;MACjCM,MAAM,GAAG,IAAI;IACf;IACA,OAAOH,KAAK,CAACC,UAAU;EACzB,CAAC,CAAC;EACF,IAAI,CAACC,MAAM,EAAE;IACXE,MAAM,CAACjE,IAAI,CAACyD,QAAQ,CAAC;EACvB;EACA,IAAI,CAACO,MAAM,EAAE;IACXC,MAAM,CAACjE,IAAI,CAAC0D,QAAQ,CAAC;EACvB;EACA,OAAOO,MAAM;AACf,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,cAAc,GAAGA,CAACC,IAAI,EAAEC,MAAM,EAAEC,KAAK,KAAK;EACnD,IAAI,CAACF,IAAI,EAAE;IACT,OAAO,IAAI;EACb;EACA,IAAI;IACFG,eAAe;IACfC,IAAI;IACJC,KAAK;IACLC,KAAK;IACLC,aAAa;IACbC,aAAa;IACbC,iBAAiB;IACjBC,SAAS;IACTrB,KAAK;IACLsB,SAAS;IACTxB;EACF,CAAC,GAAGa,IAAI;EACR,IAAI,CAACM,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EACA,IAAIM,aAAa,GAAGL,aAAa,KAAK,WAAW,IAAID,KAAK,CAACO,SAAS,GAAGP,KAAK,CAACO,SAAS,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;EAChG,IAAIrC,MAAM,GAAG,CAACyB,MAAM,IAAIC,KAAK,KAAKE,IAAI,KAAK,UAAU,IAAIE,KAAK,CAACO,SAAS,GAAGP,KAAK,CAACO,SAAS,CAAC,CAAC,GAAGD,aAAa,GAAG,CAAC;EAChHpC,MAAM,GAAGW,QAAQ,KAAK,WAAW,IAAIkB,KAAK,IAAIA,KAAK,CAACpE,MAAM,IAAI,CAAC,GAAGgC,QAAQ,CAACoC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG7B,MAAM,GAAGA,MAAM;;EAErH;EACA,IAAIyB,MAAM,KAAKZ,KAAK,IAAIsB,SAAS,CAAC,EAAE;IAClC,IAAIG,MAAM,GAAG,CAACzB,KAAK,IAAIsB,SAAS,IAAI,EAAE,EAAElB,GAAG,CAAC,CAACC,KAAK,EAAEqB,KAAK,KAAK;MAC5D,IAAIC,YAAY,GAAGb,eAAe,GAAGA,eAAe,CAACc,OAAO,CAACvB,KAAK,CAAC,GAAGA,KAAK;MAC3E,OAAO;QACL;QACA;QACAC,UAAU,EAAEW,KAAK,CAACU,YAAY,CAAC,GAAGxC,MAAM;QACxChC,KAAK,EAAEkD,KAAK;QACZlB,MAAM;QACNuC;MACF,CAAC;IACH,CAAC,CAAC;IACF,OAAOD,MAAM,CAACpF,MAAM,CAACwF,GAAG,IAAI,CAACrD,KAAK,CAACqD,GAAG,CAACvB,UAAU,CAAC,CAAC;EACrD;;EAEA;EACA,IAAIa,aAAa,IAAIC,iBAAiB,EAAE;IACtC,OAAOA,iBAAiB,CAAChB,GAAG,CAAC,CAACC,KAAK,EAAEqB,KAAK,MAAM;MAC9CpB,UAAU,EAAEW,KAAK,CAACZ,KAAK,CAAC,GAAGlB,MAAM;MACjChC,KAAK,EAAEkD,KAAK;MACZqB,KAAK;MACLvC;IACF,CAAC,CAAC,CAAC;EACL;EACA,IAAI8B,KAAK,CAACjB,KAAK,IAAI,CAACa,KAAK,IAAIQ,SAAS,IAAI,IAAI,EAAE;IAC9C,OAAOJ,KAAK,CAACjB,KAAK,CAACqB,SAAS,CAAC,CAACjB,GAAG,CAAC,CAACC,KAAK,EAAEqB,KAAK,MAAM;MACnDpB,UAAU,EAAEW,KAAK,CAACZ,KAAK,CAAC,GAAGlB,MAAM;MACjChC,KAAK,EAAEkD,KAAK;MACZlB,MAAM;MACNuC;IACF,CAAC,CAAC,CAAC;EACL;;EAEA;EACA,OAAOT,KAAK,CAACa,MAAM,CAAC,CAAC,CAAC1B,GAAG,CAAC,CAACC,KAAK,EAAEqB,KAAK,MAAM;IAC3CpB,UAAU,EAAEW,KAAK,CAACZ,KAAK,CAAC,GAAGlB,MAAM;IACjChC,KAAK,EAAE2D,eAAe,GAAGA,eAAe,CAACT,KAAK,CAAC,GAAGA,KAAK;IACvDqB,KAAK;IACLvC;EACF,CAAC,CAAC,CAAC;AACL,CAAC;AACD,IAAI4C,GAAG,GAAG,IAAI;AACd,OAAO,IAAIC,kBAAkB,GAAGf,KAAK,IAAI;EACvC,IAAIa,MAAM,GAAGb,KAAK,CAACa,MAAM,CAAC,CAAC;EAC3B,IAAI,CAACA,MAAM,IAAIA,MAAM,CAAClF,MAAM,IAAI,CAAC,EAAE;IACjC;EACF;EACA,IAAIqF,GAAG,GAAGH,MAAM,CAAClF,MAAM;EACvB,IAAIoE,KAAK,GAAGC,KAAK,CAACD,KAAK,CAAC,CAAC;EACzB,IAAIf,QAAQ,GAAGiC,IAAI,CAACC,GAAG,CAACnB,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGe,GAAG;EACjD,IAAI7B,QAAQ,GAAGgC,IAAI,CAACE,GAAG,CAACpB,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGe,GAAG;EACjD,IAAIM,KAAK,GAAGpB,KAAK,CAACa,MAAM,CAAC,CAAC,CAAC,CAAC;EAC5B,IAAIQ,IAAI,GAAGrB,KAAK,CAACa,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC,CAAC;EACjC,IAAII,KAAK,GAAGpC,QAAQ,IAAIoC,KAAK,GAAGnC,QAAQ,IAAIoC,IAAI,GAAGrC,QAAQ,IAAIqC,IAAI,GAAGpC,QAAQ,EAAE;IAC9Ee,KAAK,CAACa,MAAM,CAAC,CAACA,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5C;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIM,gBAAgB,GAAGA,CAACpF,KAAK,EAAE2E,MAAM,KAAK;EAC/C,IAAI,CAACA,MAAM,IAAIA,MAAM,CAAClF,MAAM,KAAK,CAAC,IAAI,CAAC8B,QAAQ,CAACoD,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAACpD,QAAQ,CAACoD,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;IAClF,OAAO3E,KAAK;EACd;EACA,IAAI8C,QAAQ,GAAGiC,IAAI,CAACC,GAAG,CAACL,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAI5B,QAAQ,GAAGgC,IAAI,CAACE,GAAG,CAACN,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAIL,MAAM,GAAG,CAACtE,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;EACjC,IAAI,CAACuB,QAAQ,CAACvB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,GAAG8C,QAAQ,EAAE;IAC9CwB,MAAM,CAAC,CAAC,CAAC,GAAGxB,QAAQ;EACtB;EACA,IAAI,CAACvB,QAAQ,CAACvB,KAAK,CAAC,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,GAAG+C,QAAQ,EAAE;IAC9CuB,MAAM,CAAC,CAAC,CAAC,GAAGvB,QAAQ;EACtB;EACA,IAAIuB,MAAM,CAAC,CAAC,CAAC,GAAGvB,QAAQ,EAAE;IACxBuB,MAAM,CAAC,CAAC,CAAC,GAAGvB,QAAQ;EACtB;EACA,IAAIuB,MAAM,CAAC,CAAC,CAAC,GAAGxB,QAAQ,EAAE;IACxBwB,MAAM,CAAC,CAAC,CAAC,GAAGxB,QAAQ;EACtB;EACA,OAAOwB,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIe,UAAU,GAAGC,MAAM,IAAI;EAChC,IAAIC,CAAC,GAAGD,MAAM,CAAC7F,MAAM;EACrB,IAAI8F,CAAC,IAAI,CAAC,EAAE;IACV;EACF;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,CAAC7F,MAAM,EAAE+F,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;IAChD,IAAIE,QAAQ,GAAG,CAAC;IAChB,IAAIC,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAIxF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,CAAC,EAAE,EAAEpF,CAAC,EAAE;MAC1B,IAAIH,KAAK,GAAGqB,KAAK,CAACiE,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEtE;MACA,IAAIxF,KAAK,IAAI,CAAC,EAAE;QACdsF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGE,QAAQ;QAC1BJ,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGE,QAAQ,GAAG1F,KAAK;QAClC0F,QAAQ,GAAGJ,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACLF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,QAAQ;QAC1BL,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGG,QAAQ,GAAG3F,KAAK;QAClC2F,QAAQ,GAAGL,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5B;MACA;IACF;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAII,cAAc,GAAGN,MAAM,IAAI;EACpC,IAAIC,CAAC,GAAGD,MAAM,CAAC7F,MAAM;EACrB,IAAI8F,CAAC,IAAI,CAAC,EAAE;IACV;EACF;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGH,MAAM,CAAC,CAAC,CAAC,CAAC7F,MAAM,EAAE+F,CAAC,GAAGC,CAAC,EAAE,EAAED,CAAC,EAAE;IAChD,IAAIE,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAIvF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoF,CAAC,EAAE,EAAEpF,CAAC,EAAE;MAC1B,IAAIH,KAAK,GAAGqB,KAAK,CAACiE,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC;;MAEtE;MACA,IAAIxF,KAAK,IAAI,CAAC,EAAE;QACdsF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGE,QAAQ;QAC1BJ,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGE,QAAQ,GAAG1F,KAAK;QAClC0F,QAAQ,GAAGJ,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC;MAC5B,CAAC,MAAM;QACLF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;QACnBF,MAAM,CAACnF,CAAC,CAAC,CAACqF,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACrB;MACA;IACF;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIK,gBAAgB,GAAG;EACrBC,IAAI,EAAET,UAAU;EAChB;EACAU,MAAM,EAAEhF,iBAAiB;EACzB;EACAiF,IAAI,EAAEhF,eAAe;EACrB;EACAiF,UAAU,EAAEhF,qBAAqB;EACjC;EACAiF,MAAM,EAAEhF,iBAAiB;EACzBwE,QAAQ,EAAEE;AACZ,CAAC;AACD,OAAO,IAAIO,cAAc,GAAGA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,UAAU,KAAK;EAC1D,IAAIC,cAAc,GAAGV,gBAAgB,CAACS,UAAU,CAAC;EACjD,IAAIzF,KAAK,GAAGC,UAAU,CAAC,CAAC,CAAC/B,IAAI,CAACsH,QAAQ,CAAC,CAACrG,KAAK,CAAC,CAACwG,CAAC,EAAEC,GAAG,KAAK/F,MAAM,CAACiB,iBAAiB,CAAC6E,CAAC,EAAEC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAACC,KAAK,CAACvF,cAAc;EACpH;EAAA,CACCa,MAAM,CAACuE,cAAc,CAAC;EACvB,OAAO1F,KAAK,CAACuF,IAAI,CAAC;AACpB,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASO,oBAAoBA,CAACC,aAAa,EAAE;EAClD,OAAOA,aAAa,IAAI,IAAI,GAAGC,SAAS,GAAGpG,MAAM,CAACmG,aAAa,CAAC;AAClE;AACA,OAAO,SAASE,uBAAuBA,CAACC,IAAI,EAAE;EAC5C,IAAI;IACFvD,IAAI;IACJX,KAAK;IACLmE,QAAQ;IACR9D,KAAK;IACLqB,KAAK;IACL1C;EACF,CAAC,GAAGkF,IAAI;EACR,IAAIvD,IAAI,CAACI,IAAI,KAAK,UAAU,EAAE;IAC5B;IACA;IACA,IAAI,CAACJ,IAAI,CAACyD,uBAAuB,IAAIzD,IAAI,CAAC3B,OAAO,IAAI,CAACP,SAAS,CAAC4B,KAAK,CAACM,IAAI,CAAC3B,OAAO,CAAC,CAAC,EAAE;MACpF;MACA,IAAIqF,WAAW,GAAG9F,gBAAgB,CAACyB,KAAK,EAAE,OAAO,EAAEK,KAAK,CAACM,IAAI,CAAC3B,OAAO,CAAC,CAAC;MACvE,IAAIqF,WAAW,EAAE;QACf,OAAOA,WAAW,CAAC/D,UAAU,GAAG6D,QAAQ,GAAG,CAAC;MAC9C;IACF;IACA,OAAOnE,KAAK,CAAC0B,KAAK,CAAC,GAAG1B,KAAK,CAAC0B,KAAK,CAAC,CAACpB,UAAU,GAAG6D,QAAQ,GAAG,CAAC,GAAG,IAAI;EACrE;EACA,IAAIhH,KAAK,GAAG2B,iBAAiB,CAACuB,KAAK,EAAE,CAAC5B,SAAS,CAACO,OAAO,CAAC,GAAGA,OAAO,GAAG2B,IAAI,CAAC3B,OAAO,CAAC;;EAElF;EACA,OAAO,CAACP,SAAS,CAACtB,KAAK,CAAC,GAAGwD,IAAI,CAACM,KAAK,CAAC9D,KAAK,CAAC,GAAG,IAAI;AACrD;AACA,OAAO,IAAImH,sBAAsB,GAAGC,KAAK,IAAI;EAC3C,IAAI;IACF5D,IAAI;IACJX,KAAK;IACLb,MAAM;IACNgF,QAAQ;IACR9D,KAAK;IACLqB;EACF,CAAC,GAAG6C,KAAK;EACT,IAAI5D,IAAI,CAACI,IAAI,KAAK,UAAU,EAAE;IAC5B,OAAOf,KAAK,CAAC0B,KAAK,CAAC,GAAG1B,KAAK,CAAC0B,KAAK,CAAC,CAACpB,UAAU,GAAGnB,MAAM,GAAG,IAAI;EAC/D;EACA,IAAIhC,KAAK,GAAG2B,iBAAiB,CAACuB,KAAK,EAAEM,IAAI,CAAC3B,OAAO,EAAE2B,IAAI,CAACM,KAAK,CAACa,MAAM,CAAC,CAAC,CAACJ,KAAK,CAAC,CAAC;EAC9E,OAAO,CAACjD,SAAS,CAACtB,KAAK,CAAC,GAAGwD,IAAI,CAACM,KAAK,CAAC9D,KAAK,CAAC,GAAGgH,QAAQ,GAAG,CAAC,GAAGhF,MAAM,GAAG,IAAI;AAC7E,CAAC;AACD,OAAO,IAAIqF,iBAAiB,GAAGC,KAAK,IAAI;EACtC,IAAI;IACFC;EACF,CAAC,GAAGD,KAAK;EACT,IAAI3C,MAAM,GAAG4C,WAAW,CAACzD,KAAK,CAACa,MAAM,CAAC,CAAC;EACvC,IAAI4C,WAAW,CAAC3D,IAAI,KAAK,QAAQ,EAAE;IACjC;IACA,IAAId,QAAQ,GAAGiC,IAAI,CAACC,GAAG,CAACL,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IAC7C;IACA,IAAI5B,QAAQ,GAAGgC,IAAI,CAACE,GAAG,CAACN,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IAC7C,IAAI7B,QAAQ,IAAI,CAAC,IAAIC,QAAQ,IAAI,CAAC,EAAE;MAClC,OAAO,CAAC;IACV;IACA,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAChB,OAAOA,QAAQ;IACjB;IACA,OAAOD,QAAQ;EACjB;EACA,OAAO6B,MAAM,CAAC,CAAC,CAAC;AAClB,CAAC;AACD,IAAI6C,iBAAiB,GAAGpB,IAAI,IAAI;EAC9B,IAAIqB,IAAI,GAAGrB,IAAI,CAACqB,IAAI,CAAC,CAAC,CAAC,CAACvI,MAAM,CAACqC,QAAQ,CAAC;EACxC,OAAO,CAACwD,IAAI,CAACC,GAAG,CAAC,GAAGyC,IAAI,CAAC,EAAE1C,IAAI,CAACE,GAAG,CAAC,GAAGwC,IAAI,CAAC,CAAC;AAC/C,CAAC;AACD,IAAIC,gBAAgB,GAAG/C,MAAM,IAAI;EAC/B,OAAO,CAACA,MAAM,CAAC,CAAC,CAAC,KAAKgD,QAAQ,GAAG,CAAC,GAAGhD,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,KAAK,CAACgD,QAAQ,GAAG,CAAC,GAAGhD,MAAM,CAAC,CAAC,CAAC,CAAC;AAC1F,CAAC;AACD,OAAO,IAAIiD,sBAAsB,GAAGA,CAACC,WAAW,EAAEC,UAAU,EAAEC,QAAQ,KAAK;EACzE,IAAIF,WAAW,IAAI,IAAI,EAAE;IACvB,OAAOhB,SAAS;EAClB;EACA,OAAOa,gBAAgB,CAAC5I,MAAM,CAACC,IAAI,CAAC8I,WAAW,CAAC,CAACG,MAAM,CAAC,CAAC1D,MAAM,EAAE2D,OAAO,KAAK;IAC3E,IAAIC,KAAK,GAAGL,WAAW,CAACI,OAAO,CAAC;IAChC,IAAI;MACFE;IACF,CAAC,GAAGD,KAAK;IACT,IAAIvD,MAAM,GAAGwD,WAAW,CAACH,MAAM,CAAC,CAACI,GAAG,EAAElF,KAAK,KAAK;MAC9C,IAAImF,MAAM,GAAG3G,SAAS,CAACwB,KAAK,EAAE4E,UAAU,EAAEC,QAAQ,CAAC;MACnD,IAAIO,CAAC,GAAGd,iBAAiB,CAACa,MAAM,CAAC;MACjC,OAAO,CAACtD,IAAI,CAACC,GAAG,CAACoD,GAAG,CAAC,CAAC,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEvD,IAAI,CAACE,GAAG,CAACmD,GAAG,CAAC,CAAC,CAAC,EAAEE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC,EAAE,CAACX,QAAQ,EAAE,CAACA,QAAQ,CAAC,CAAC;IACzB,OAAO,CAAC5C,IAAI,CAACC,GAAG,CAACL,MAAM,CAAC,CAAC,CAAC,EAAEL,MAAM,CAAC,CAAC,CAAC,CAAC,EAAES,IAAI,CAACE,GAAG,CAACN,MAAM,CAAC,CAAC,CAAC,EAAEL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;EACzE,CAAC,EAAE,CAACqD,QAAQ,EAAE,CAACA,QAAQ,CAAC,CAAC,CAAC;AAC5B,CAAC;AACD,OAAO,IAAIY,aAAa,GAAG,iDAAiD;AAC5E,OAAO,IAAIC,aAAa,GAAG,kDAAkD;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIC,iBAAiB,GAAGA,CAACjF,IAAI,EAAEX,KAAK,EAAE6F,KAAK,KAAK;EACrD,IAAIlF,IAAI,IAAIA,IAAI,CAACM,KAAK,IAAIN,IAAI,CAACM,KAAK,CAACO,SAAS,EAAE;IAC9C,IAAIsE,SAAS,GAAGnF,IAAI,CAACM,KAAK,CAACO,SAAS,CAAC,CAAC;IACtC,IAAI,CAACqE,KAAK,IAAIC,SAAS,GAAG,CAAC,EAAE;MAC3B,OAAOA,SAAS;IAClB;EACF;EACA,IAAInF,IAAI,IAAIX,KAAK,IAAIA,KAAK,CAACpD,MAAM,IAAI,CAAC,EAAE;IACtC,IAAImJ,YAAY,GAAGjI,MAAM,CAACkC,KAAK,EAAE5D,CAAC,IAAIA,CAAC,CAACkE,UAAU,CAAC;IACnD,IAAI6D,QAAQ,GAAGW,QAAQ;IACvB,KAAK,IAAIxH,CAAC,GAAG,CAAC,EAAE2E,GAAG,GAAG8D,YAAY,CAACnJ,MAAM,EAAEU,CAAC,GAAG2E,GAAG,EAAE3E,CAAC,EAAE,EAAE;MACvD,IAAI0I,GAAG,GAAGD,YAAY,CAACzI,CAAC,CAAC;MACzB,IAAI2I,IAAI,GAAGF,YAAY,CAACzI,CAAC,GAAG,CAAC,CAAC;MAC9B6G,QAAQ,GAAGjC,IAAI,CAACC,GAAG,CAAC,CAAC6D,GAAG,CAAC1F,UAAU,IAAI,CAAC,KAAK2F,IAAI,CAAC3F,UAAU,IAAI,CAAC,CAAC,EAAE6D,QAAQ,CAAC;IAC/E;IACA,OAAOA,QAAQ,KAAKW,QAAQ,GAAG,CAAC,GAAGX,QAAQ;EAC7C;EACA,OAAO0B,KAAK,GAAG7B,SAAS,GAAG,CAAC;AAC9B,CAAC;AACD,OAAO,SAASkC,eAAeA,CAACC,KAAK,EAAE;EACrC,IAAI;IACFC,oBAAoB;IACpBpH,OAAO;IACPqH,OAAO;IACPlJ,KAAK;IACLmJ;EACF,CAAC,GAAGH,KAAK;EACT,OAAOzJ,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAE0J,oBAAoB,CAAC,EAAE,CAAC,CAAC,EAAE;IAChEpH,OAAO;IACPqH,OAAO;IACPlJ,KAAK;IACLmJ;EACF,CAAC,CAAC;AACJ;AACA,OAAO,SAASC,kBAAkBA,CAACC,YAAY,EAAExH,OAAO,EAAE;EACxD,IAAIwH,YAAY,EAAE;IAChB,OAAO5I,MAAM,CAAC4I,YAAY,CAAC;EAC7B;EACA,IAAI,OAAOxH,OAAO,KAAK,QAAQ,EAAE;IAC/B,OAAOA,OAAO;EAChB;EACA,OAAOgF,SAAS;AAClB;AACA,OAAO,IAAIyC,4BAA4B,GAAGA,CAACnG,UAAU,EAAEV,MAAM,KAAK;EAChE,IAAIA,MAAM,KAAK,YAAY,EAAE;IAC3B,OAAOU,UAAU,CAACoG,MAAM;EAC1B;EACA,IAAI9G,MAAM,KAAK,UAAU,EAAE;IACzB,OAAOU,UAAU,CAACqG,MAAM;EAC1B;EACA,OAAO3C,SAAS;AAClB,CAAC;AACD,OAAO,IAAI4C,wBAAwB,GAAGA,CAACC,QAAQ,EAAEjH,MAAM,KAAK;EAC1D,IAAIA,MAAM,KAAK,SAAS,EAAE;IACxB,OAAOiH,QAAQ,CAACC,KAAK;EACvB;EACA,OAAOD,QAAQ,CAACE,MAAM;AACxB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}